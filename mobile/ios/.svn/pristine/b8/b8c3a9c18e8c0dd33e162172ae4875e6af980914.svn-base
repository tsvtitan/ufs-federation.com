//
//  UFSLoader.m
//  UFS
//
//  Created by iD-EAST on 16.07.13.
//  Copyright (c) 2013 iD EAST. All rights reserved.
//

#import "UFSLoader.h"
#import <Foundation/Foundation.h>
#import "DataTransformer.h"
#import "OpenUDID.h"

//#import "CoreDataManager.h"

static UFSLoader *kSharedLoader = nil;

@implementation UFSLoader

@synthesize reach, client;

+ (UFSLoader *)shared
{
	if (kSharedLoader == nil)
	{
		kSharedLoader = [[UFSLoader alloc] init];
	}
	return kSharedLoader;
}

+ (BOOL)reachable
{
    
//	NetworkStatus netStatus = [[UFSLoader shared].reach currentReachabilityStatus];
//        switch (netStatus)
//    {
//        case ReachableViaWWAN:
//        {
//            
//			return YES;
//		}
//        case ReachableViaWiFi:
//        {
//           
//			return YES;
//		}
//		default:
//		{
//			break;
//		}
//    }
	return [UFSLoader shared].reachabilityStatus;
}

- (UFSLoader *)init
{
	self = [super initWithBaseURL:[NSURL URLWithString:kServerBaseURL]];
	if (self)
	{
//		[[NSNotificationCenter defaultCenter] addObserver:self
//												 selector:@selector(reachabilityChanged:)
//													 name:kReachabilityChangedNotification
//												   object:nil];
//		
//		reach = [[Reachability reachabilityWithHostName:kServerBaseURL] retain];
//		[reach startNotifier];
       
        [self registerHTTPOperationClass:[AFJSONRequestOperation class]];
         [self setDefaultHeader:@"Accept" value:@"application/json"];
       [AFJSONRequestOperation addAcceptableContentTypes:[NSSet setWithObject:@"text/html"]];
        
        [self setParameterEncoding:AFFormURLParameterEncoding];
//        [self setParameterEncoding:AFJSONParameterEncoding];
        [self setAllowsInvalidSSLCertificate:YES];
        [self setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {
            if (status == AFNetworkReachabilityStatusReachableViaWiFi)
            {
                NSLog(@"reach WIFI");
                 self.reachabilityStatus=YES;
                [[NSNotificationCenter defaultCenter] postNotificationName:kReachableOk object:nil];
               
            }
            if (status == AFNetworkReachabilityStatusReachableViaWWAN)
            {
                NSLog(@"reach WAN");
                self.reachabilityStatus=YES;
                 [[NSNotificationCenter defaultCenter] postNotificationName:kReachableOk object:nil];
                 
            }
            if (status == AFNetworkReachabilityStatusNotReachable)
            {
                NSLog(@"reach no");
                self.reachabilityStatus=NO;
                 [[NSNotificationCenter defaultCenter] postNotificationName:kNotReachable object:nil];
                 
            }
        }];
//		self.networkQueue = [ASINetworkQueue queue];
//		[self.networkQueue setDelegate:self];
//		[self.networkQueue setRequestDidFinishSelector:@selector(requestFinished:)];
//		[self.networkQueue setRequestDidFailSelector:@selector(requestFailed:)];
//		[self.networkQueue setQueueDidFinishSelector:@selector(queueFinished:)];
//        [self.networkQueue setShowAccurateProgress:YES];
////      [self.networkQueue setDownloadProgressDelegate:self];
//
//		[self.networkQueue go];
	}
	return self;
}

- (void)dealloc
{
	kSharedLoader = nil;
	
//    SAFE_KILL(networkQueue);
//	[self.networkQueue cancelAllOperations];
//	
	[[NSNotificationCenter defaultCenter] removeObserver:self];
	[reach release];
	
	[super dealloc];
}

+ (BOOL)reachableWiFi
{
	NetworkStatus netStatus = [[UFSLoader shared].reach currentReachabilityStatus];
	return (netStatus == ReachableViaWiFi);
}

- (void)reachabilityChanged:(NSNotification* )note
{
    NSLog(@"reachabilityChanged:");
}

+ (NSString *)paramsFromDictionary:(NSDictionary *)params {
    
    NSMutableString *result = [NSMutableString string];
    
    for (NSString *key in params.allKeys) {
        
        if (result.length) {
            
            [result appendString:@"&"];
        }
        
        [result appendFormat:@"%@=%@", key, [params objectForKey:key]];
    }
    
    return [[result copy] autorelease];
    
}
+(BOOL)requestPostAuth: (NSString *)screenHeigth andWidth:(NSString *)screenWidth
{
    
//     [[CoreDataManager shared] removeDataWithEntityName:@"CategoriesDB"];
    NSLog(@"device name %@",[[UIDevice currentDevice] name]);
    NSString *currentVersion = [NSString stringWithFormat:@"%@ %@",[[UIDevice currentDevice] systemName],[[UIDevice currentDevice] systemVersion]];
    NSString *currentResolution = [NSString stringWithFormat:@"%@x%@",screenWidth,screenHeigth];
    if ([[UIDevice currentDevice] userInterfaceIdiom]==UIUserInterfaceIdiomPhone)
    {
        if (RETINA)
        {
            currentResolution = @"960×640";
        }
        else
        {
             currentResolution = @"480×320";
        }
    }
    else
    {
        if (RETINA)
        {
            currentResolution = @"2048×1536";
        }
        else
        {
            currentResolution = @"1024×768";
        }

    }
    NSUserDefaults *userDef = [NSUserDefaults standardUserDefaults];
    
    /* tsv */
    NSString *openUDID = [OpenUDID value];
    // 65151e34e34f229bc37a6123cfc7fad4120c5227 = phone (iOS 7.0)
    // dd58bc2568daddef2e041e49702981a9cae9153f = pad (iOS 6.1)
    // 8c80366365125e6bff4f946aa2df2846a5c64dbb = simulator (iPhone Retina (4-inch) iOS 6.1)
    
    NSString *version = [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleVersion"];
    /* tsv */
   
    NSNumber *expiredOld = [userDef valueForKey:kTokenExpiredTime];
    // Ask is old token expired, if it TRUE delete all download files
    if (expiredOld==nil || [expiredOld isEqualToNumber:[NSNumber numberWithInt:0]] || [@([[NSDate date] timeIntervalSince1970]) compare:expiredOld]==NSOrderedDescending || [@([[NSDate date] timeIntervalSince1970]) compare:expiredOld]==NSOrderedSame)
    {
        
    //  Removing all data
        NSLog(@"remove all data");
       
        NSArray *news = [CoreDataManager objects:@"NewsDB" withPredicate:[NSPredicate predicateWithFormat:@"category == nil || subcategory == nil"] inMainContext:YES];
        if (news.count) {
            
            NSInteger countObjects = news.count;
            while (countObjects > 0) {
                countObjects --;
                NewsDB *new = [news objectAtIndex:countObjects];
                [CoreDataManager.shared.managedObjectContext deleteObject:new];
            }
        }

//        [[CoreDataManager shared] removeDataWithEntityName:@"SubCatDB"];
       
        [[UFSLoader shared] postPath:[NSString stringWithFormat:UFSURLAuth] parameters:[NSDictionary dictionaryWithObjects:@[@"Apple",[[UIDevice currentDevice] name],currentResolution,currentVersion,openUDID,version] forKeys:@[@"madeBy",@"deviceModel",@"screenSize",@"os",@"id",@"version"]] success:^(AFHTTPRequestOperation *operation, id responseObject)
        {
             NSLog(@"successs................");
    //        id responseData = [JSONDecoder.decoder objectWithData:responseObject];
            if ([responseObject isKindOfClass:[NSDictionary class]])
            {
                NSString *tokenStr = [[responseObject objectForKey:@"result"] objectForKey:@"token"];
                NSNumber *expired = @([[[responseObject objectForKey:@"result"] objectForKey:@"expired"] integerValue]);

//                NSDate *currentDate = [NSDate date];
//                NSNumber *tokenTemp = @([currentDate timeIntervalSince1970]+100);
//                NSLog(@"token temp = %@",tokenTemp);
                if (tokenStr.length)
                {
                    NSUserDefaults *userDef = [NSUserDefaults standardUserDefaults];
                    
                        [userDef setValue:tokenStr forKey:kTokenForSession];
                        [userDef setValue:expired forKey:kTokenExpiredTime];
                        [userDef synchronize];
                        NSLog(@"token saved %@ expired %@",tokenStr,expired);
//                     [[CoreDataManager shared] removeDataWithEntityName:@"NewsDB"];
                    [[CoreDataManager shared] removeDataWithEntityName:@"SubCatDB"];
                    [[CoreDataManager shared] removeDataWithEntityName:@"CategoriesDB"];
//                     [[CoreDataManager shared] removeDataOlderThanDate:[NSDate date]];
//                        [UFSLoader requestPostRubrics];
                }
                
            }
        } failure:^(AFHTTPRequestOperation *operation, NSError *error)
        {
            [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationRequestFaild object:nil];
//            [self stopAndClear];
             NSLog(@"Fail................auth%@",error.localizedFailureReason);
        }];
        return false;
    }
    else
    {
        if ([screenHeigth isEqualToString:@"first"])
        {
             [UFSLoader requestPostRubrics];
        }
        NSLog(@"token is same %@",[userDef valueForKey:kTokenForSession]);
        return true;
    }
}
+(void)requestPostRubrics
{
    NSUserDefaults *userDef = [NSUserDefaults standardUserDefaults];
    

    NSString *token=[userDef valueForKey:kTokenForSession];
    //    NSString *token=@"11111sssded2ed";
    if (token.length)
    {
    [[UFSLoader shared] postPath:[NSString stringWithFormat:@"%@",UFSURLCategories] parameters:[NSDictionary dictionaryWithObject:token forKey:@"token"] success:^(AFHTTPRequestOperation *operation, id responseObject)
     {
//         NSNumber *err = [NSNumber numberWithInt:100];
         NSString *errorCode = [NSString stringWithFormat:@"%@",[[responseObject objectForKey:@"error"] objectForKey:@"code"] ];
//         errorCode = [NSString stringWithFormat:@"%@",err];
         NSString *errorMessage = ((NSString *)[[responseObject objectForKey:@"error"] objectForKey:@"message"]);
         NSLog(@"error = %@ message %@",errorCode,errorMessage);
         if (errorCode.length || ![[responseObject objectForKey:@"result"] allObjects].count)
         {
             NSLog(@"reauth categ................");
             if ([[errorMessage lowercaseString] rangeOfString:@"invalid"].location!=NSNotFound || [[errorMessage lowercaseString] rangeOfString:@"locked"].location!=NSNotFound || [[errorMessage lowercaseString] rangeOfString:@"token"].location!=NSNotFound || [[errorMessage lowercaseString] rangeOfString:@"not found"].location!=NSNotFound ||[errorCode isEqualToString:@"100"])
             {
//                 [[CoreDataManager shared] removeDataWithEntityName:@"CategoriesDB"];
//                 [[CoreDataManager shared] removeDataWithEntityName:@"SubCatDB"];
                  NSLog(@"reauth categ begins...............");
                 [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationRequestFaild object:errorMessage];
             }
             
         }
         else
         {
             NSLog(@"successs categ................");
             
             
             [DataTransformer parseData:responseObject userInfo:@{@"type":@(DTOperationTypeRubrics)}];
             [UFSLoader requestPostMainNews:@"" CategoryId:@"16" andSubCategoryId:@"" andNewsID:@""];
         }
        
     } failure:^(AFHTTPRequestOperation *operation, NSError *error)
     {
         [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationRequestFaild object:nil];
         NSLog(@"Fail................categ%@",error.localizedFailureReason);
     }];
    }
    else
    {
//        [UFSLoader requestPostAuth:@"" andWidth:@""];
    }
}

+(void)requestPostMainNews:(NSString *)dateFrom CategoryId:(NSString *)catId andSubCategoryId:(NSString *)subCatId andNewsID:(NSString *)newsId
{
    NSString *dateLimit = @"";
    if ([dateFrom rangeOfString:@" "].location!=NSNotFound)
    {
        dateLimit = [dateFrom substringFromIndex:[dateFrom rangeOfString:@" "].location];
        dateFrom = [dateFrom substringToIndex:[dateFrom rangeOfString:@" "].location];
    }
    NSUserDefaults *userDef = [NSUserDefaults standardUserDefaults];
    
    NSString *date = dateFrom.length?dateFrom:[NSString stringWithFormat:@"%@",[NSNumber numberWithInt:[[NSDate date] timeIntervalSince1970]]];
    NSString *token=[userDef valueForKey:kTokenForSession];
//    token=@"11111sssded2ed";
    NSDictionary *params = nil;
        
        //params = [NSDictionary dictionaryWithObjects:@[catId,subCatId,newsId, date,dateLimit,@"20",token]
        /* tsv */params = [NSDictionary dictionaryWithObjects:@[catId,subCatId,newsId, date,dateLimit,@"10",token]
        forKeys:@[@"categoryID",@"subcategoryID",@"newsID",@"timestamp",@"limitDateTime",@"offset",@"token"]];
//    NSLog(@"params = %@",params);
        if (token.length)
    {
        [[UFSLoader shared] postPath:UFSURLNews parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject)
         {
             NSLog(@"successs news main................");
             NSString *errorCode = [NSString stringWithFormat:@"%@",[[responseObject objectForKey:@"error"] objectForKey:@"code"] ];
             //         errorCode = [NSString stringWithFormat:@"%@",err];
             NSString *errorMessage = ((NSString *)[[responseObject objectForKey:@"error"] objectForKey:@"message"]);
             NSLog(@"error = %@ message %@",errorCode,errorMessage);
             if (errorCode.length || ![[responseObject objectForKey:@"result"] allObjects].count)
             {
                 NSLog(@"reauth categ................");
                 if ([[errorMessage lowercaseString] rangeOfString:@"invalid"].location!=NSNotFound || [[errorMessage lowercaseString] rangeOfString:@"locked"].location!=NSNotFound || [[errorMessage lowercaseString] rangeOfString:@"token"].location!=NSNotFound || [errorCode isEqualToString:@"100"])
                 {
                     [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationRequestFaild object:errorMessage];
                 }

             }
//             [[CoreDataManager shared] removeDataOlderThanDate:[NSDate date]];
             //         NSDictionary *resp = [JSONDecoder.decoder objectWithData:responseObject];
             [DataTransformer parseData:responseObject userInfo:@{@"type":@(DTOperationTypeNews)}];
             
         } failure:^(AFHTTPRequestOperation *operation, NSError *error)
         {
              [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationRequestFaild object:nil];
             NSLog(@"Fail................%@",error.localizedFailureReason);
         }];
    }
    else
    {
//        [UFSLoader requestPostAuth:@"" andWidth:@""];
    }
}
+(void)requestPostTableNewsWithSubCategoryId:(NSString *)subCatId
{
    NSUserDefaults *userDef = [NSUserDefaults standardUserDefaults];
    
    NSString *token=[userDef valueForKey:kTokenForSession];
    NSDictionary *params = nil;
    if (subCatId.length)
    {
        params = [NSDictionary dictionaryWithObjects:@[subCatId,token] forKeys:@[@"subcategoryID", @"token"]];
    }
    //NSLog(@"%@",params);
    if (token.length)
    {
        [[UFSLoader shared] postPath:UFSURLTableNews parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject)
         {
             NSString *errorCode = [NSString stringWithFormat:@"%@",[[responseObject objectForKey:@"error"] objectForKey:@"code"] ];
             //         errorCode = [NSString stringWithFormat:@"%@",err];
             NSString *errorMessage = ((NSString *)[[responseObject objectForKey:@"error"] objectForKey:@"message"]);
             NSLog(@"error = %@ message %@",errorCode,errorMessage);
             if (errorCode.length || ![[responseObject objectForKey:@"result"] allObjects].count)
             {
                 NSLog(@"reauth categ................");
                 if ([[errorMessage lowercaseString] rangeOfString:@"invalid"].location!=NSNotFound || [[errorMessage lowercaseString] rangeOfString:@"locked"].location!=NSNotFound || [[errorMessage lowercaseString] rangeOfString:@"token"].location!=NSNotFound || [[errorMessage lowercaseString] rangeOfString:@"not found"].location!=NSNotFound ||[errorCode isEqualToString:@"100"])
                 {
                     //                 [[CoreDataManager shared] removeDataWithEntityName:@"CategoriesDB"];
                     //                 [[CoreDataManager shared] removeDataWithEntityName:@"SubCatDB"];
                     NSLog(@"reauth categ begins...............");
                     [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationRequestFaild object:errorMessage];
                 }
                 
             }
             else
             {

             NSLog(@"successs tables...............");
             //         NSDictionary *resp = [JSONDecoder.decoder objectWithData:responseObject];
             [DataTransformer parseData:responseObject userInfo:@{@"type":@(DTOperationTypeTables)}];
             }
         } failure:^(AFHTTPRequestOperation *operation, NSError *error)
         {
             NSLog(@"Fail................%@",error.localizedFailureReason);
         }];
    }
    else
    {
        [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationRequestFaild object:nil];
        [UFSLoader requestPostAuth:@"" andWidth:@""];
    }
}

+(void)requestPostDebtMarketWithSubCategoryId:(NSString *)subCatId
{
    NSUserDefaults *userDef = [NSUserDefaults standardUserDefaults];
    
    NSString *token=[userDef valueForKey:kTokenForSession];
    NSDictionary *params = nil;
    if (subCatId.length)
    {
        params = [NSDictionary dictionaryWithObjects:@[subCatId,token] forKeys:@[@"subcategoryID", @"token"]];
    }
    if (token.length)
    {
        [[UFSLoader shared] postPath:UFSDebtMarket parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject)
         {
             NSString *errorCode = [NSString stringWithFormat:@"%@",[[responseObject objectForKey:@"error"] objectForKey:@"code"] ];
             //         errorCode = [NSString stringWithFormat:@"%@",err];
             NSString *errorMessage = ((NSString *)[[responseObject objectForKey:@"error"] objectForKey:@"message"]);
             NSLog(@"error = %@ message %@",errorCode,errorMessage);
             if (errorCode.length || ![[responseObject objectForKey:@"result"] allObjects].count)
             {
                 NSLog(@"reauth categ................");
                 if ([[errorMessage lowercaseString] rangeOfString:@"invalid"].location!=NSNotFound || [[errorMessage lowercaseString] rangeOfString:@"locked"].location!=NSNotFound || [[errorMessage lowercaseString] rangeOfString:@"token"].location!=NSNotFound || [[errorMessage lowercaseString] rangeOfString:@"not found"].location!=NSNotFound ||[errorCode isEqualToString:@"100"])
                 {
                     //                 [[CoreDataManager shared] removeDataWithEntityName:@"CategoriesDB"];
                     //                 [[CoreDataManager shared] removeDataWithEntityName:@"SubCatDB"];
                     NSLog(@"reauth categ begins...............");
                     [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationRequestFaild object:errorMessage];
                 }
                 
             }
             else
             {

             NSLog(@"successs groups...............");
             //         NSDictionary *resp = [JSONDecoder.decoder objectWithData:responseObject];
             [DataTransformer parseData:responseObject userInfo:@{@"type":@(DTOperationTypeGroups)}];
             }
         } failure:^(AFHTTPRequestOperation *operation, NSError *error)
         {
             NSLog(@"Fail................%@",error.localizedFailureReason);
         }];
    }
    else
    {
        [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationRequestFaild object:nil];
        [UFSLoader requestPostAuth:@"" andWidth:@""];
    }
}

+(void)requestPostContacts
{
    NSUserDefaults *userDef = [NSUserDefaults standardUserDefaults];
    
    NSString *token=[userDef valueForKey:kTokenForSession];
    NSDictionary *params = [NSDictionary dictionaryWithObjects:@[token] forKeys:@[@"token"]];
    if (token.length)
    {
        [[UFSLoader shared] postPath:UFSContacts parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject)
         {
             NSString *errorCode = [NSString stringWithFormat:@"%@",[[responseObject objectForKey:@"error"] objectForKey:@"code"] ];
             //         errorCode = [NSString stringWithFormat:@"%@",err];
             NSString *errorMessage = ((NSString *)[[responseObject objectForKey:@"error"] objectForKey:@"message"]);
             NSLog(@"error = %@ message %@",errorCode,errorMessage);
             if (errorCode.length || ![[responseObject objectForKey:@"result"] allObjects].count)
             {
                 NSLog(@"reauth categ................");
                 if ([[errorMessage lowercaseString] rangeOfString:@"invalid"].location!=NSNotFound || [[errorMessage lowercaseString] rangeOfString:@"locked"].location!=NSNotFound || [[errorMessage lowercaseString] rangeOfString:@"token"].location!=NSNotFound || [[errorMessage lowercaseString] rangeOfString:@"not found"].location!=NSNotFound ||[errorCode isEqualToString:@"100"])
                 {
                     //                 [[CoreDataManager shared] removeDataWithEntityName:@"CategoriesDB"];
                     //                 [[CoreDataManager shared] removeDataWithEntityName:@"SubCatDB"];
                     NSLog(@"reauth categ begins...............");
                     [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationRequestFaild object:errorMessage];
                 }
                 
             }
             else
             {

             NSLog(@"successs contacts...............");
             //         NSDictionary *resp = [JSONDecoder.decoder objectWithData:responseObject];
             [DataTransformer parseData:responseObject userInfo:@{@"type":@(DTOperationTypeContacts)}];
             }
         } failure:^(AFHTTPRequestOperation *operation, NSError *error)
         {
             NSLog(@"Fail................%@",error.localizedFailureReason);
         }];
    }
    else
    {
        [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationRequestFaild object:nil];
        [UFSLoader requestPostAuth:@"" andWidth:@""];
    }

}

+ (void)requestPostActionsWithCategoryIdentifier:(NSString *)categoryId
{
	NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
	NSString *token = [userDefaults valueForKey:kTokenForSession];
	NSDictionary *params = [NSDictionary dictionaryWithObjects:@[token, categoryId] forKeys:@[@"token", @"categoryID"]];
	
	if (token.length)
	{
		[[UFSLoader shared] postPath:UFSStock parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject)
		{
            NSString *errorCode = [NSString stringWithFormat:@"%@",[[responseObject objectForKey:@"error"] objectForKey:@"code"] ];
            //         errorCode = [NSString stringWithFormat:@"%@",err];
            NSString *errorMessage = ((NSString *)[[responseObject objectForKey:@"error"] objectForKey:@"message"]);
            NSLog(@"error = %@ message %@",errorCode,errorMessage);
            if (errorCode.length || ![[responseObject objectForKey:@"result"] allObjects].count)
            {
                NSLog(@"reauth categ................");
                if ([[errorMessage lowercaseString] rangeOfString:@"invalid"].location!=NSNotFound || [[errorMessage lowercaseString] rangeOfString:@"locked"].location!=NSNotFound || [[errorMessage lowercaseString] rangeOfString:@"token"].location!=NSNotFound || [[errorMessage lowercaseString] rangeOfString:@"not found"].location!=NSNotFound ||[errorCode isEqualToString:@"100"])
                {
                    //                 [[CoreDataManager shared] removeDataWithEntityName:@"CategoriesDB"];
                    //                 [[CoreDataManager shared] removeDataWithEntityName:@"SubCatDB"];
                    NSLog(@"reauth categ begins...............");
                    [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationRequestFaild object:errorMessage];
                }
                
            }
            else
            {

			NSLog(@"Success actions.....");
//			NSLog(@"Actions response: %@", responseObject);
			[DataTransformer parseData:responseObject userInfo:@{ @"type" : @(DTOperationTypeStock) }];
            }
		}
		failure:^(AFHTTPRequestOperation *operation, NSError *error)
		{
			NSLog(@"Fail actions.....%@", error.localizedFailureReason);
		}];
	}
	else
	{
        [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationRequestFaild object:nil];
		[UFSLoader requestPostAuth:@"" andWidth:@""];
	}
}
+ (void)requestPostHTMLDataWithCategoryIdentifier:(NSString *)categoryId andSubCategoryId:(NSString *)subCatId
{
    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
	NSString *token = [userDefaults valueForKey:kTokenForSession];
	NSDictionary *params = [NSDictionary dictionaryWithObjects:@[token, categoryId, subCatId] forKeys:@[@"token", @"categoryID", @"subcategoryID"]];
	
	if (token.length)
	{
		[[UFSLoader shared] postPath:UFSHTMLData parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject)
         {
             NSLog(@"Success html data.....");
             //			NSLog(@"Actions response: %@", responseObject);
             [DataTransformer parseData:responseObject userInfo:@{ @"type" : @(DTOperationTypeHTML) }];
         }
                             failure:^(AFHTTPRequestOperation *operation, NSError *error)
         {
             NSLog(@"Fail html data.....%@", error.localizedFailureReason);
         }];
	}
	else
	{
        [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationRequestFaild object:nil];
		[UFSLoader requestPostAuth:@"" andWidth:@""];
	}

}
+(AFHTTPRequestOperation *)requestGetFile:(NSString *)url AndName:(NSString *)fileName
{

    AFHTTPRequestOperation *operationGetFile = [[AFHTTPRequestOperation alloc] initWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:[NSString stringWithFormat:kServerBasePath,url]]]];

    [[UFSLoader shared] enqueueHTTPRequestOperation:operationGetFile];
    [operationGetFile setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
        [FileSystem storeData:responseObject withPath:fileName];
        [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationFileLoaded object:nil];
    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
        if ([error code]!=-999)
            [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationFileLoadFailed object:nil];
    }];
    return operationGetFile;
}
+(void)stopAndClear
{
    [[[UFSLoader shared] operationQueue] cancelAllOperations];
}
+(AFHTTPRequestOperation *)getImage:(NSString *)image AndName:(NSString *)name
{
    AFHTTPRequestOperation *operationGetImage = [[AFHTTPRequestOperation alloc] initWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:[NSString stringWithFormat:kServerBasePath,image]]]];
    
    [[UFSLoader shared] enqueueHTTPRequestOperation:operationGetImage];
    [operationGetImage setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject)
    {
        [FileSystem storeData:responseObject withPath:name];
        [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationImageLoaded object:name];
    } failure:^(AFHTTPRequestOperation *operation, NSError *error)
    {
        [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationImageLoadFailed object:nil];
    }];
    return operationGetImage;
}
+(AFJSONRequestOperation *)requestGetDateForNewsWithCategoryId:(NSString *)catId AndSubCatId:(NSString *)subCatId
{
    NSUserDefaults *userDef = [NSUserDefaults standardUserDefaults];
    
    NSString *token=[userDef valueForKey:kTokenForSession];
    NSDictionary *params = [NSDictionary dictionaryWithObjects:@[catId, subCatId, token] forKeys:@[@"categoryID",@"subcategoryID", @"token"]];
    
        params = [NSDictionary dictionaryWithObjects:@[catId, subCatId, token] forKeys:@[@"categoryID",@"subcategoryID", @"token"]];
   
    AFJSONRequestOperation *operationGetDate = [[[AFJSONRequestOperation alloc] initWithRequest:[[UFSLoader shared] requestWithMethod:@"POST" path:UFSURLDatesOfNews parameters:params]] autorelease];

                                                
    return operationGetDate;

}

/* tsv */
+(void)requestPostQRCode:(NSString *)text
{
    NSUserDefaults *userDef = [NSUserDefaults standardUserDefaults];
    
    NSString *token=[userDef valueForKey:kTokenForSession];
    NSDictionary *params = [NSDictionary dictionaryWithObjects:@[text, token] forKeys:@[@"text", @"token"]];
    
    if (token.length)
    {
        [[UFSLoader shared] postPath:UFSQRCode parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject)
         {
             NSString *errorCode = [NSString stringWithFormat:@"%@",[[responseObject objectForKey:@"error"] objectForKey:@"code"] ];
             NSString *errorMessage = ((NSString *)[[responseObject objectForKey:@"error"] objectForKey:@"message"]);
             
             NSLog(@"error = %@ message %@",errorCode,errorMessage);
             
             if (errorCode.length || ![[responseObject objectForKey:@"result"] allObjects].count)
             {
                 NSLog(@"reauth qrcode................");
                 if ([[errorMessage lowercaseString] rangeOfString:@"invalid"].location!=NSNotFound || [[errorMessage lowercaseString] rangeOfString:@"locked"].location!=NSNotFound || [[errorMessage lowercaseString] rangeOfString:@"token"].location!=NSNotFound || [[errorMessage lowercaseString] rangeOfString:@"not found"].location!=NSNotFound ||[errorCode isEqualToString:@"100"])
                 {
              
                     NSLog(@"reauth qrcode begins...............");
                     [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationRequestFaild object:errorMessage];
                 }
                 
             }
             else
             {
                 NSLog(@"successs qrcode...............");
                 [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationQRCode object:responseObject];
                 //[DataTransformer parseData:responseObject userInfo:@{@"type":@(DTOperationTypeQRCode)}];
             }
         } failure:^(AFHTTPRequestOperation *operation, NSError *error)
         {
             NSLog(@"Fail................%@",error.localizedFailureReason);
         }];
    }
    else
    {
        [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationRequestFaild object:nil];
        [UFSLoader requestPostAuth:@"" andWidth:@""];
    }
    
}

+(void)requestPostPromotion:(NSString *)promotionID AndAccepted:(NSString *)accepted
{
    NSUserDefaults *userDef = [NSUserDefaults standardUserDefaults];
    
    NSString *token=[userDef valueForKey:kTokenForSession];
    NSDictionary *params = [NSDictionary dictionaryWithObjects:@[promotionID, accepted, token] forKeys:@[@"promotionID", @"accepted", @"token"]];
    
    if (token.length)
    {
        [[UFSLoader shared] postPath:UFSPromotion parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject)
         {
             NSString *errorCode = [NSString stringWithFormat:@"%@",[[responseObject objectForKey:@"error"] objectForKey:@"code"] ];
             NSString *errorMessage = ((NSString *)[[responseObject objectForKey:@"error"] objectForKey:@"message"]);
             
             NSLog(@"error = %@ message %@",errorCode,errorMessage);
             
             if (errorCode.length || ![[responseObject objectForKey:@"result"] allObjects].count)
             {
                 NSLog(@"reauth promotion................");
                 if ([[errorMessage lowercaseString] rangeOfString:@"invalid"].location!=NSNotFound || [[errorMessage lowercaseString] rangeOfString:@"locked"].location!=NSNotFound || [[errorMessage lowercaseString] rangeOfString:@"token"].location!=NSNotFound || [[errorMessage lowercaseString] rangeOfString:@"not found"].location!=NSNotFound ||[errorCode isEqualToString:@"100"])
                 {
                     
                     NSLog(@"reauth promotion begins...............");
                     [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationRequestFaild object:errorMessage];
                 }
                 
             } else {
                 
                 NSLog(@"successs promotion...............");
                 [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationPromotion object:responseObject];
            }
         } failure:^(AFHTTPRequestOperation *operation, NSError *error)
         {
             NSLog(@"Fail................%@",error.localizedFailureReason);
         }];
    }
    else
    {
        [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationRequestFaild object:nil];
        [UFSLoader requestPostAuth:@"" andWidth:@""];
    }
    
}
/* tsv */


//+ (ASIHTTPRequest *)requestImage:(NSString *)imageUrlString
//{
//	NSString *urlString = imageUrlString;
//	
//	ASIHTTPRequest *request = [[[ASIHTTPRequest alloc] initWithURL:[NSURL URLWithString:urlString]] autorelease];
//    
//    [request setAllowCompressedResponse:YES];
//    request.validatesSecureCertificate = NO;
//    //	request.allowResumeForFileDownloads = YES;
//    [[UFSLoader shared].networkQueue setDownloadProgressDelegate:self];
//	request.userInfo = [NSDictionary dictionaryWithObject:urlString forKey:@"imageUrlString"];
//	[[UFSLoader shared].networkQueue addOperation:request];
//	
//	NSLog(@"imgsrc=\"%@\"", urlString);
//    
//	return request;
//   
//}
//
//+ (ASIHTTPRequest *)requestGetFileWhithURL:(NSNumber *)fileUrlString withDelegate:(id)progressDelegate
//{
//	NSString *urlString = [NSString stringWithFormat:UFSURLGetFile,fileUrlString];
//	
//	ASIHTTPRequest *request = [[[ASIHTTPRequest alloc] initWithURL:[NSURL URLWithString:urlString]] autorelease];
//    
//    [request setAllowCompressedResponse:NO];
//    request.validatesSecureCertificate = NO;
//    request.allowResumeForFileDownloads = YES;
//    request.timeOutSeconds = 300;
//    [request setShowAccurateProgress:YES];
//    [request setDelegate:self];
//    [request setDownloadProgressDelegate:progressDelegate];
////    [request setDidFinishSelector:@selector(requestComplete:)];
//    [[UFSLoader shared].networkQueue setDownloadProgressDelegate:progressDelegate];
//	request.userInfo = [NSDictionary dictionaryWithObject:urlString forKey:@"fileUrlString"];
////    [request startAsynchronous];
//	[[UFSLoader shared].networkQueue addOperation:request];
////	request:didReceiveData:
//	NSLog(@"fileSrc=\"%@\"", urlString);
//    
//	return request;
//    
//}
//
//+ (ASIHTTPRequest *)requestGetGallery:(NSInteger) page
//{
//    ASIHTTPRequest *request = [[[ASIHTTPRequest alloc] initWithURL:[NSURL URLWithString:[NSString stringWithFormat:UFSURLFotoList,page]]] autorelease];
//    
//    [request setAllowCompressedResponse:YES];
//	request.timeOutSeconds = 300;
//    request.userInfo = @{@"type":@(DTOperationTypeGalleryList)};
//	[[UFSLoader shared].networkQueue addOperation:request];
//    
//	return request;
//}
//
//+ (ASIHTTPRequest *)requestGetPreviewGallery:(NSNumber *) idGallery
//{
//    ASIHTTPRequest *request = [[[ASIHTTPRequest alloc] initWithURL:[NSURL URLWithString:[NSString stringWithFormat:UFSURLGetSomethingFromUFSmens,idGallery,0]]] autorelease];
//    
//    [request setAllowCompressedResponse:YES];
//	request.timeOutSeconds = 300;
//    request.userInfo = @{@"type":@(DTOperationTypePreviewGallery)};
//	[[UFSLoader shared].networkQueue addOperation:request];
//    
//	return request;
//    
//}
//
//+ (ASIHTTPRequest *)requestGetRelese:(NSInteger) page{
//    
//    
//    
//    ASIHTTPRequest *request = [[[ASIHTTPRequest alloc] initWithURL:[NSURL URLWithString:[NSString stringWithFormat:UFSURLReleaseList,page]]] autorelease];
//    
//    [request setAllowCompressedResponse:YES];
//
//	request.timeOutSeconds = 300;
//    request.userInfo = @{@"type":@(DTOperationTypeNews)};//?geo_id for lenta or informer (->news->)
//	[[UFSLoader shared].networkQueue addOperation:request];
//    
//	return request;
//}
//
//
//+ (ASIHTTPRequest *)requestGetNews:(NSInteger) page
//{
//    ASIHTTPRequest *request = [[[ASIHTTPRequest alloc] initWithURL:[NSURL URLWithString:[NSString stringWithFormat:UFSURLNewsList,page]]] autorelease];
//
//    [request setAllowCompressedResponse:YES];
//	request.timeOutSeconds = 300;
//    request.userInfo = @{@"type":@(DTOperationTypeNews)};
//	[[UFSLoader shared].networkQueue addOperation:request];
//    
//	return request;
//}
//+ (ASIHTTPRequest *)requestGetInnovationNews:(NSInteger) page
//{
//    ASIHTTPRequest *request = [[[ASIHTTPRequest alloc] initWithURL:[NSURL URLWithString:[NSString stringWithFormat:UFSURLNewsInnovationsList,page]]] autorelease];
//    
//    [request setAllowCompressedResponse:YES];
//	request.timeOutSeconds = 300;
//    request.userInfo = @{@"type":@(DTOperationTypeNews)};
//	[[UFSLoader shared].networkQueue addOperation:request];
//    return request;
//}
//
//+ (ASIHTTPRequest *)requestGetFuturePic:(NSInteger) page
//{
//    ASIHTTPRequest *request = [[[ASIHTTPRequest alloc] initWithURL:[NSURL URLWithString:[NSString stringWithFormat:UFSURLFuturePictureList,page]]] autorelease];
//    
//    [request setAllowCompressedResponse:YES];
//	request.timeOutSeconds = 300;
//    request.userInfo = @{@"type":@(DTOperationTypeNews)};
//	[[UFSLoader shared].networkQueue addOperation:request];
//    
//	return request;
// 
//}
//- (void)request:(ASIHTTPRequest *)request didReceiveData:(NSData *)data
//{
//    
//}
//- (void) requestComplete:(ASIHTTPRequest *)request
//{
//    NSString *fileUrlString = [request.userInfo objectForKey:@"fileUrlString"];
//    [FileSystem storeData:request.responseData withPath:fileUrlString];
//    [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationFileLoaded object:fileUrlString];
//}
//- (void)requestFinished:(ASIHTTPRequest *)request
//{
//    
//    if ([request.userInfo objectForKey:@"imageUrlString"])
//    {
//		NSString *imageUrlString = [request.userInfo objectForKey:@"imageUrlString"];
//		[FileSystem storeData:request.responseData withPath:imageUrlString];
//		[[NSNotificationCenter defaultCenter] postNotificationName:kNotificationImageLoaded object:imageUrlString];
//	}
//    else if ([request.userInfo objectForKey:@"fileUrlString"])
//    {
//		NSString *fileUrlString = [request.userInfo objectForKey:@"fileUrlString"];
//		[FileSystem storeData:request.responseData withPath:fileUrlString];
//		[[NSNotificationCenter defaultCenter] postNotificationName:kNotificationFileLoaded object:fileUrlString];
//	}
//    else{
//        NSLog(@"\"%@\"", request.url.absoluteString);
//        
//        
//        [DataTransformer parseData:request.responseData userInfo:request.userInfo];
//        [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationLoaderObjectLoaded object:request.url.absoluteString];
//    }
//}
//- (void)requestFailed:(ASIHTTPRequest *)request
//{
//    
//	NSLog(@"\"%@\"\nError:\"%@\"", request.url.absoluteString, request.error);
//    
////    if ([[request.userInfo objectForKey:@"type"] isEqualToString:UFSURLNewsList]) {
//    
//		[[NSNotificationCenter defaultCenter] postNotificationName:kNotificationLoaderObjectFailed object:[request.userInfo objectForKey:@"type"]];
////	}else {
////        
////        [[NSNotificationCenter defaultCenter] postNotificationName:kNotificationLoaderObjectFailed object:request.url.absoluteString];
////    }
//}
//
//- (void)queueFinished:(ASINetworkQueue *)queue {
//    if ([[queue.userInfo objectForKey:@"type"] isEqualToString:@"fileUrlString"])
//    {
//        NSLog(@"%llu",queue.totalBytesToDownload);
//    }
//    queue.uploadProgressDelegate = self;
//}
//- (void)setProgress:(float)newProgress
//{
//    NSLog(@"progress %f",newProgress);
//}
//+ (void)clearDelegate
//{
//    [[UFSLoader shared].networkQueue setDownloadProgressDelegate:self];
//    [[UFSLoader shared].networkQueue cancelAllOperations];
//}
@end
